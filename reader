package com.sbi.yono.document.batch.reader;

import java.util.List;

import javax.sql.DataSource;

import org.springframework.batch.item.ItemReader;
import org.springframework.batch.item.ParseException;
import org.springframework.batch.item.UnexpectedInputException;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

import com.sbi.yono.document.batch.dto.NtbReq;
import com.sbi.yono.document.batch.rowmapper.NtbReqRowMapper;
import com.sbi.yono.document.savingsaccount.edms.upload.EdmsUploadConstants;
import com.tcs.techbone.channel.global.reader.GlobalConfigPropertiesReader;

@Component
public class ListReadingItemReader implements ItemReader<List<NtbReq>> {

	private final JdbcTemplate jdbcTemplate;
	int pagesize = Integer.parseInt((String) GlobalConfigPropertiesReader.getInstance().getPropertyById(EdmsUploadConstants.EDMS_SEGEMENT_SIZE));
	boolean finished = false;

	public ListReadingItemReader(DataSource dataSource) {
		this.jdbcTemplate = new JdbcTemplate();
		this.jdbcTemplate.setDataSource(dataSource);
	}

	@Override
	public List<NtbReq> read() throws Exception, UnexpectedInputException, ParseException {

		if (finished) {
			return null;
		}
		List<NtbReq> list = jdbcTemplate.query("select t1.ref_no, t1.cif,t1.channel_id,t1.updated_dt ,t1.job_id, \r\n"
				+ "t2.acnt_nmbr,t2.updtd_dt as crtn_dt,t2.isd_cd,\r\n"
				+ "t3.frst_nm,t3.last_nm,t3.mddle_nm,t3.brnch_cd,t3.ckyc_no,t3.mbl_no,t3.pan_dtls->>'pan' As pan\r\n"
				+ "from yono_dcmnt.edms_req AS t1\r\n"
				+ "INNER JOIN yono_accnt.accnt_onbrdng AS t2 ON t1.ref_no = t2.ref_no\r\n"
				+ "INNER JOIN yono_cstmr.cstmr_onbrdng AS t3 ON t2.ref_no = t3.ref_no\r\n"
				+ "where channel_id in ('Y2NDSSA','Y2NBNSA','Y2NBSSA')\r\n" + "order by updated_dt asc limit "
				+ pagesize, new NtbReqRowMapper(NtbReq.class));
		
		if (list.isEmpty()) {
			finished = true;
			return null;
		}
		return list;

	}
}
--------
package com.sbi.yono.document.batch.reader;

import static org.junit.jupiter.api.Assertions.*;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import javax.sql.DataSource;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;

import com.sbi.yono.document.batch.dto.NtbReq;
import com.sbi.yono.document.savingsaccount.edms.upload.EdmsUploadConstants;
import com.tcs.techbone.channel.global.reader.GlobalConfigPropertiesReader;

@ExtendWith(MockitoExtension.class)
public class ListReadingItemReaderTest {

    /**
     * Custom JdbcTemplate that returns scripted results without hitting a DB.
     */
    private static class TestJdbcTemplate extends JdbcTemplate {
        private final List<List<NtbReq>> scriptedResults = new ArrayList<>();
        private int callCount = 0;

        void addResult(List<NtbReq> result) {
            scriptedResults.add(result);
        }

        @Override
        public <T> List<T> query(String sql, RowMapper<T> rowMapper) {
            // Ignore SQL and RowMapper, only return scripted results
            if (callCount < scriptedResults.size()) {
                @SuppressWarnings("unchecked")
                List<T> result = (List<T>) scriptedResults.get(callCount++);
                return result;
            }
            // Default: no more data
            return Collections.emptyList();
        }

        int getCallCount() {
            return callCount;
        }
    }

    // -------------------- reflection helpers --------------------

    private void setField(Object target, String fieldName, Object value) throws Exception {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }

    private Object getField(Object target, String fieldName) throws Exception {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        return field.get(target);
    }

    /**
     * Creates a ListReadingItemReader while:
     *  - mocking GlobalConfigPropertiesReader so pagesize is set to a valid int
     *  - injecting a custom JdbcTemplate (so no real DB is used)
     */
    private ListReadingItemReader createReaderWith(TestJdbcTemplate testJdbcTemplate) throws Exception {
        ListReadingItemReader reader;

        // Mock the static GlobalConfigPropertiesReader.getInstance()
        try (MockedStatic<GlobalConfigPropertiesReader> mockedStatic =
                     Mockito.mockStatic(GlobalConfigPropertiesReader.class)) {

            GlobalConfigPropertiesReader mockConfig = Mockito.mock(GlobalConfigPropertiesReader.class);
            mockedStatic.when(GlobalConfigPropertiesReader::getInstance).thenReturn(mockConfig);
            // Return a valid integer string for EDMS_SEGEMENT_SIZE
            Mockito.when(mockConfig.getPropertyById(EdmsUploadConstants.EDMS_SEGEMENT_SIZE))
                   .thenReturn("5");

            // Any non-null DataSource is fine; we'll replace jdbcTemplate anyway
            DataSource dataSource = Mockito.mock(DataSource.class);
            reader = new ListReadingItemReader(dataSource);
        }

        // Replace the real JdbcTemplate with our TestJdbcTemplate
        setField(reader, "jdbcTemplate", testJdbcTemplate);

        return reader;
    }

    // -------------------- tests --------------------

    @Test
    public void testReadReturnsListWhenNotFinishedAndDataPresent() throws Exception {
        TestJdbcTemplate testJdbcTemplate = new TestJdbcTemplate();
        List<NtbReq> firstResult = new ArrayList<>();
        firstResult.add(new NtbReq());   // non-empty list
        testJdbcTemplate.addResult(firstResult);

        ListReadingItemReader reader = createReaderWith(testJdbcTemplate);

        // First call: should return the non-empty list
        List<NtbReq> result = reader.read();

        assertNotNull(result, "Result should not be null when data is present");
        assertEquals(1, result.size(), "Result size should match scripted data");

        // finished flag should remain false
        boolean finished = (boolean) getField(reader, "finished");
        assertFalse(finished, "finished should remain false when data is returned");
    }

    @Test
    public void testReadReturnsNullAndSetsFinishedWhenNoData() throws Exception {
        TestJdbcTemplate testJdbcTemplate = new TestJdbcTemplate();
        // First (and only) call returns empty list
        testJdbcTemplate.addResult(Collections.emptyList());

        ListReadingItemReader reader = createReaderWith(testJdbcTemplate);

        // First call: empty list => finished = true and returns null
        List<NtbReq> result = reader.read();

        assertNull(result, "Result should be null when no data is returned");
        boolean finished = (boolean) getField(reader, "finished");
        assertTrue(finished, "finished should be set to true when no data is returned");
    }

    @Test
    public void testReadReturnsNullWhenAlreadyFinished() throws Exception {
        TestJdbcTemplate testJdbcTemplate = new TestJdbcTemplate();
        ListReadingItemReader reader = createReaderWith(testJdbcTemplate);

        // Force finished = true before calling read()
        setField(reader, "finished", true);

        // Call read: should immediately return null and not hit JdbcTemplate
        List<NtbReq> result = reader.read();

        assertNull(result, "When finished is true, read() must return null");
        assertEquals(0, testJdbcTemplate.getCallCount(),
                "JdbcTemplate.query should not be called when finished is already true");
    }
}

-----------------------------------------------------

package com.sbi.yono.document.batch.reader;

import java.util.List;

import javax.sql.DataSource;

import org.springframework.batch.item.ItemReader;
import org.springframework.batch.item.ParseException;
import org.springframework.batch.item.UnexpectedInputException;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

import com.sbi.yono.document.batch.dto.NtbReq;
import com.sbi.yono.document.batch.rowmapper.NtbReqRowMapper;
import com.sbi.yono.document.savingsaccount.edms.upload.EdmsUploadConstants;
import com.tcs.techbone.channel.global.reader.GlobalConfigPropertiesReader;

@Component
public class ListReadingRetryItemReader implements ItemReader<List<NtbReq>> {

	private final JdbcTemplate jdbcTemplate;
	int pagesize = Integer.parseInt((String) GlobalConfigPropertiesReader.getInstance().getPropertyById(EdmsUploadConstants.EDMS_SEGEMENT_SIZE));
	private boolean finished = false;

	public ListReadingRetryItemReader(DataSource dataSource) {
		this.jdbcTemplate = new JdbcTemplate();
		this.jdbcTemplate.setDataSource(dataSource);
	}

	@Override
	public List<NtbReq> read() throws Exception, UnexpectedInputException, ParseException {
		if (finished) {
			return null;
		}
		List<NtbReq> list = jdbcTemplate.query("select t1.ref_no, t1.cif,t1.channel_id,t1.updtd_dt ,t1.job_id, \r\n"
				+ "t2.acnt_nmbr,t2.updtd_dt as crtn_dt,t2.isd_cd,\r\n"
				+ "t3.frst_nm,t3.last_nm,t3.mddle_nm,t3.brnch_cd,t3.ckyc_no,t3.mbl_no,t3.pan_dtls->>'pan' As pan\r\n"
				+ "from yono_dcmnt.edms_req AS t1\r\n"
				+ "INNER JOIN yono_accnt.accnt_onbrdng AS t2 ON t1.ref_no = t2.ref_no\r\n"
				+ "INNER JOIN yono_cstmr.cstmr_onbrdng AS t3 ON t2.ref_no = t3.ref_no\r\n"
				+ "where channel_id in ('Y2NBNSA')\r\n" + "order by t1.updtd_dt asc limit "
				+ pagesize, new NtbReqRowMapper(NtbReq.class));
		if (list.isEmpty()) {
			finished = true;
			return null;
		}
		return list;

	}
}
-----------------------------
package com.sbi.yono.document.batch.reader;

import static org.junit.jupiter.api.Assertions.*;

import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import javax.sql.DataSource;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.MockedStatic;
import org.mockito.Mockito;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;

import com.sbi.yono.document.batch.dto.NtbReq;
import com.sbi.yono.document.savingsaccount.edms.upload.EdmsUploadConstants;
import com.tcs.techbone.channel.global.reader.GlobalConfigPropertiesReader;

@ExtendWith(MockitoExtension.class)
public class ListReadingRetryItemReaderTest {

    /**
     * Custom JdbcTemplate that returns scripted results without touching a real DB.
     */
    private static class TestJdbcTemplate extends JdbcTemplate {
        private final List<List<NtbReq>> scriptedResults = new ArrayList<>();
        private int callCount = 0;

        void addResult(List<NtbReq> result) {
            scriptedResults.add(result);
        }

        @Override
        public <T> List<T> query(String sql, RowMapper<T> rowMapper) {
            // Ignore SQL and RowMapper, just return scripted results
            if (callCount < scriptedResults.size()) {
                @SuppressWarnings("unchecked")
                List<T> result = (List<T>) scriptedResults.get(callCount++);
                return result;
            }
            // Default: no more data
            return Collections.emptyList();
        }

        int getCallCount() {
            return callCount;
        }
    }

    // -------------------- reflection helpers --------------------

    private void setField(Object target, String fieldName, Object value) throws Exception {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(target, value);
    }

    private Object getField(Object target, String fieldName) throws Exception {
        Field field = target.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        return field.get(target);
    }

    /**
     * Creates a ListReadingRetryItemReader while:
     *  - mocking GlobalConfigPropertiesReader so pagesize is a valid int
     *  - injecting a custom JdbcTemplate (so no real DB is used)
     */
    private ListReadingRetryItemReader createReaderWith(TestJdbcTemplate testJdbcTemplate) throws Exception {
        ListReadingRetryItemReader reader;

        // Mock the static GlobalConfigPropertiesReader.getInstance()
        try (MockedStatic<GlobalConfigPropertiesReader> mockedStatic =
                     Mockito.mockStatic(GlobalConfigPropertiesReader.class)) {

            GlobalConfigPropertiesReader mockConfig = Mockito.mock(GlobalConfigPropertiesReader.class);
            mockedStatic.when(GlobalConfigPropertiesReader::getInstance).thenReturn(mockConfig);

            // Return a valid integer string for EDMS_SEGEMENT_SIZE so pagesize parses correctly
            Mockito.when(mockConfig.getPropertyById(EdmsUploadConstants.EDMS_SEGEMENT_SIZE))
                   .thenReturn("5");

            // Any non-null DataSource is fine; we'll replace jdbcTemplate anyway
            DataSource dataSource = Mockito.mock(DataSource.class);
            reader = new ListReadingRetryItemReader(dataSource);
        }

        // Replace the real JdbcTemplate with our TestJdbcTemplate
        setField(reader, "jdbcTemplate", testJdbcTemplate);

        return reader;
    }

    // -------------------- tests --------------------

    @Test
    public void testReadReturnsListWhenNotFinishedAndDataPresent() throws Exception {
        TestJdbcTemplate testJdbcTemplate = new TestJdbcTemplate();
        List<NtbReq> firstResult = new ArrayList<>();
        firstResult.add(new NtbReq());   // non-empty list
        testJdbcTemplate.addResult(firstResult);

        ListReadingRetryItemReader reader = createReaderWith(testJdbcTemplate);

        // First call: should return the non-empty list
        List<NtbReq> result = reader.read();

        assertNotNull(result, "Result should not be null when data is present");
        assertEquals(1, result.size(), "Result size should match scripted data");

        // finished flag should remain false
        boolean finished = (boolean) getField(reader, "finished");
        assertFalse(finished, "finished should remain false when data is returned");
    }

    @Test
    public void testReadReturnsNullAndSetsFinishedWhenNoData() throws Exception {
        TestJdbcTemplate testJdbcTemplate = new TestJdbcTemplate();
        // First (and only) call returns empty list
        testJdbcTemplate.addResult(Collections.emptyList());

        ListReadingRetryItemReader reader = createReaderWith(testJdbcTemplate);

        // First call: empty list => finished = true and returns null
        List<NtbReq> result = reader.read();

        assertNull(result, "Result should be null when no data is returned");
        boolean finished = (boolean) getField(reader, "finished");
        assertTrue(finished, "finished should be set to true when no data is returned");
    }

    @Test
    public void testReadReturnsNullWhenAlreadyFinished() throws Exception {
        TestJdbcTemplate testJdbcTemplate = new TestJdbcTemplate();
        ListReadingRetryItemReader reader = createReaderWith(testJdbcTemplate);

        // Force finished = true before calling read()
        setField(reader, "finished", true);

        // Call read: should immediately return null and not hit JdbcTemplate
        List<NtbReq> result = reader.read();

        assertNull(result, "When finished is true, read() must return null");
        assertEquals(0, testJdbcTemplate.getCallCount(),
                "JdbcTemplate.query should not be called when finished is already true");
    }
}
